% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fundata.R
\name{fundata}
\alias{fundata}
\title{Generate Functional data using pre-specified coefficients}
\usage{
fundata(n, p, nbasis, tt, basisname = "bspline", eta, norder = 4)
}
\arguments{
\item{n}{An integer specifying the number of observations, i.e., sample size.}

\item{p}{An integer specifying the number of functional predictors.}

\item{nbasis}{An integer specifying the number of basis functions.}

\item{tt}{A numeric vector of time points at which the functional data is
evaluated.}

\item{basisname}{A character string for the type of basis functions to use,
either 'bspline' or 'fourier'.  Default is 'bspline'.}

\item{eta}{A matrix of coefficients of dimension \code{nbasis * n * p}.}

\item{norder}{An integer specifying the order of B-splines, which is one
higher than their degree.  The default of 4 gives cubic splines.}
}
\value{
\code{fundata} returns a list containing:
\itemize{
\item \code{X}: An array of generated functional data of dimension
\code{n * nt * p}, where \code{nt} denotes the number of time
points.
\item \code{Xc}: An array of centered functional data of dimension
\code{n * nt * p}, where \code{nt} denotes the number of time
points.
\item \code{mfpca.scores}: A matrix of FPCA scores.
.       \item \code{xcoefs}: The array of the coefficients used for generating
the functional data of dimension \code{nbasis * n * p}.  Note that, if
Fourier basis is used and \code{nbasis} is even number, then it is rounded
up to the nearest odd integer to preserve the pairing of sine and cosine
functions.
\item \code{xcoefs.mat}: The matrix version of the coefficients with
dimension \code{n * (p * nbasis)}.  Note that, if Fourier basis is used
and \code{nbasis} is even number, then it is rounded up to the nearest odd
integer to preserve the pairing of sine and cosine functions.
\item \code{basis}: The basis object used for functional data generation.
}
}
\description{
\code{fundata} generates functional data using either B-spline or Fourier
basis functions.
}
\details{
This function generates functional data by expanding a set of coefficients
(\code{eta}) onto a chosen basis (either B-spline or Fourier).  Then, functional
principal component analysis (FPCA) is applied to obtain a low-dimensional
representation of the data.
}
\examples{
# Example 1
# set the parameters
n <- 100
p <- 3
nbasis <- 4
tt <- seq(0, 1, length.out = 100)
eta.mat <- mvtnorm::rmvnorm(n, mean = rep(0, p * nbasis))
eta <- array(eta.mat, dim = c(nbasis, n, p))
# create the functional predictors
data <- fundata(n, p, nbasis, tt, 'bspline', eta)
str(data)
X <- data$X
# plot the first functional predictor for illustration
 fda::matplot(tt, t(X[, , 1]), type = "l", lty = 1, col = 1:n,
 xlab = "Time", ylab = "Value", main = paste("Functional Predictor", 1))

# Example 2
# set the parameters
n <- 100
p <- 5
nbasis <- 4
time <- seq(0, 1, length.out = 101)
SigmaCov <- matrix(0, nrow = p * nbasis, ncol = p * nbasis)
for (j in 1:p) {
 index.j <-(((j - 1) * nbasis + 1):(j * nbasis))
 diag(SigmaCov[index.j, index.j]) <- c(2, 1, 1/2, 1/4)
}
eta <- mvtnorm::rmvnorm(n, mean = rep(0, p * nbasis), sigma = SigmaCov)
# create the functional predictors
result <- fundata(n, p, nbasis, time, eta)
x <- result$x
xc <- result$xc
# plot the first functional predictor for illustration
fda::matplot(time, t(x[, , 1]), type = "l", lty = 1, col = 1:n,
    xlab = "Time", ylab = "Value", main = paste("Functional Predictor", 1))

}
