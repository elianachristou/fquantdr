% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sonf.R
\name{sonf}
\alias{sonf}
\title{Scalar-on-function regression}
\usage{
sonf(y, xfd, dev2_penalty = FALSE, lambda = NULL)
}
\arguments{
\item{y}{A numeric vector of length \code{n}, representing the scalar
response.}

\item{xfd}{A functional data object of class \code{fd}. The basis type must
be either 'bspline' or 'fourier'.}

\item{dev2_penalty}{A logical flag indicating whether to apply a second
derivative penalty (default is \code{FALSE}).}

\item{lambda}{A penalty parameter used if \code{dev2_penalty} is \code{TRUE}.}
}
\value{
\code{sonf} computes a scalar-on-function regression and returns:
\item{betacoef}{The regression coefficients.}
\item{betafd}{The functional data objects for the beta coefficients.}
\item{yhat}{The \code{n}-dimensional vector of predicted values for \code{y}.}
\item{X}{The \code{n x (nbasis * p)} design matrix used in the
regression.}
}
\description{
\code{sonf} models the relationship between a scalar response variable and
one or more functional predictor variables.  The function offers the option
to include a second derivative penalty to smooth the estimated regression
coefficients.
}
\details{
This function models the relationship between a scalar response variable
and one or more functional predictor variables using basis functions.  The
input \code{xfd} needs to be a functional object (\code{fd}).  The function returns
the regression coefficients, the functional data objects for these
coefficients, the estimated response values, and the design matrix.
}
\examples{
# set the parameters
n <- 100
p <- 5
nbasis <- 4
nt <- 100
tt <- seq(0, 1, length.out = nt)
eta.mat <- mvtnorm::rmvnorm(n, mean = rep(0, p * nbasis))
eta <- array(eta.mat, dim = c(nbasis, n, p))
# Generate the functional data
fd.data <- fundata(n, p, nbasis, tt, 'bspline', eta)
# Prepare the fd object
x.fd <- fda::fd(fd.data$xcoefs, fd.data$basis)
# Generate the model
error <- rnorm(n)
y <- 3 * fd.data$mfpca.scores[, 1] + error
# Perform scalar-on-function without penalty
result_no_penalty <- sonf(y, x.fd, dev2_penalty = FALSE)
print("Regression coefficients without penalty:")
print(result_no_penalty$betacoef)
# Compare y and yhat
cor(y, result_no_penalty$yhat)
# Perform scalar-on-function regression with penalty
lambda <- 0.1
result_with_penalty <- sonf(y, x.fd, dev2_penalty = TRUE, lambda = lambda)
cor(y, result_with_penalty$yhat)

}
