---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

#fquantdr

<!-- badges: start -->
<!-- [![Build Status](https://travis-ci.com/elianachristou/fquantdr.svg?branch=master)](https://travis-ci.com/elianachristou/fquantdr) -->
<!-- badges: end -->

fquantdr: Dimension Reduction Techniques for Conditional Quantiles for 
    Functional Data
====================================================================

The R package `fquantdr` performs dimension reduction techniques for conditional quantiles of a scalar response given the functional predictors.  Specifically, the method aims at replacing the infinite-dimensional functional predictors with a few finite predictors without losing important information on the conditional quantiles while maintaining a flexible nonparametric model.  For details of the methodology, see Christou et al.\ (2024).
<!-- [Christou, E., Solea, E., Wang, S., and Song, J. (2024+) Sufficient Dimension Reduction for Conditional Quantiles for Functional Data. *Journal*, volume, pages](link) -->

The main function of the package is `fcqs`, which estimates the directions of the functional central quantile subspace.  However, the package includes more functions that are helpful to run `fcqs`.  Specifically, `mfsir` performs functional sliced inverse regression (FSIR) of [Ferre and Yao (2003)](https://doi.org/10.1080/0233188031000112845) and `sonf` performs scalar-on-function linear regression.  Moreover, `fundata` generates functional data and `mcorr` computes the multiple correlation between two vector or matrices.  

## Installation
You can install the released version of `fquantdr` from [CRAN](https://CRAN.R-project.org) with: 

``` r
install.packages("fquantdr")
```

and the development version from [GitHub](https://github.com/) with:

``` {r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("elianachristou/fquantdr")
```

## Introducing `fcqs`

This function computes the directions that span the \eqn{\tau}th functional central quantile subspace. These directions represent functions that can
be linearly applied via the inner product to give predictors that reduce the dimension of the infinitely-dimensional ones without losing any information on the conditional quantile.  

The function requires several inputs:

* `x` a 3-dimensional array ($n \times nt \times p$) representing the functional predictors, where $n$ is the number of observations, $nt$ is the number of time points, and $p$ is the number of predictors.
* `y` a numeric vector of length $n$ representing the scalar response.
* `time` a numeric vector of length $nt$ representing the time points at which the functional data is evaluated.
* `nbasis` the number of basis functions for smoothing the functional predictors.
* `tau` the quantile level 
* `d_tau` the number of directions the user wants to extract. 

The function then returns:

* `betacoef` the functional parameters that span the functional central quantile subspace
* `betax` the resulting sufficient predictors, calculated as the inner product between `betacoef` and `x`.

This is a basic example that shows how to apply the function.  First, let's define the basic parameters, such as the sample size, the number of predictors, the number of times points, the vector of time points, the quantile level, and the number of basis functions that we wish to smooth the functional predictors.    

```{r}
library(fquantdr)

# define the parameters
set.seed(1234)
n <- 100
p <- 5
nt <- 101
time <- seq(0, 1, length = nt)
tau <- 0.5
nbasis <- 4
```

Then, we need to generate the functional predictors and the scalar response.  For the functional predictors, we can use the `fundata` function that is available in the package.  An additional argument, `eta`, is required for the function and it represents the matrix of coefficients with dimensions $n$ by $p \times nbasis$.  For the scalar response, we use the model $$Y = 3 \langle \beta_1, X \rangle + \epsilon,$$ where $\epsilon$ is the error term and $\beta_1$ represent an eigenfunction.  In this case, the $\tau$-th functional central quantile subspace is generated by $\{\beta_1\}$.  

```{r}
# Generate the functional predictors
eta <- matrix(rnorm(n * p * nbasis), nrow = n, ncol = p * nbasis)
data.output <- fundata(n, p, nbasis, time, eta)
xc <- data.output$xc

# Generate the scalar response
P <- eigen(cov(eta))$vectors
mfpca.scores <- eta %*% P
error <- rnorm(n)
y <- 3 * mfpca.scores[, 1] + error
```



This is a basic example which shows you how to solve a common problem using 'mfsir':

```{r example data}
library(fquantdr)

# Example data
set.seed(123)
X <- array(rnorm(1000), dim = c(100, 10, 2))  # 100 observations, 10 time points, 2 predictors
y <- rnorm(100)  # response variable
H <- 5  # number of slices
nbasis <- 10  # number of basis functions

# Running the FSIR function
result_mfsir <- mfsir(X, y, H, nbasis)
print(result_mfsir$phi)  # eigenvectors
print(result_mfsir$betas)  # sufficient predictors
```

## Usage
The fquantdr package can be used in various scenarios such as:

* Transforming high-dimensional discrete data into functional data
* Applying dimension reduction techniques to simplify data analysis
* Using quantile regression for robust statistical modeling


### Functional Sliced Inverse Regression (FSIR)
The mfsir function performs Functional Sliced Inverse Regression with multivariate functional predictors.

```{r example of mfsir}
# Example data for mfsir
X <- array(rnorm(1000), dim = c(100, 10, 2))  # 100 observations, 10 time points, 2 predictors
y <- rnorm(100)  # response variable
H <- 5  # number of slices
nbasis <- 10  # number of basis functions

# Running the mfsir function
result_mfsir <- mfsir(X, y, H, nbasis)
print(result_mfsir$phi)  # eigenvectors
print(result_mfsir$betas)  # sufficient predictors
```

### Functional Central Quantile Subspace (FCQS)
__fcqs: FCQS with Multivariate Functional Predictors__

The fcqs function incorporates multivariate functional predictors and fits a scalar-on-function regression for multivariate data.

```{r example of fcqs}
# Example data for fcqs
X <- array(rnorm(1000), dim = c(100, 10, 2))  # 100 observations, 10 time points, 2 predictors
y <- rnorm(100)  # response variable
t <- seq(0, 1, length.out = 10)
tau <- 0.5
d_tau <- 2
nbasis <- 10

# Running the fcqs function
result_fcqs <- fcqs(X, y, t, nbasis, tau, d_tau)
print(result_fcqs$ffun)   # Functional parameters that span the FCQS
print(result_fcqs$betax)  # Resulting sufficient predictor
```

### Example with Plots
You can also embed plots in your analysis:

```{r example}
# Example plot
plot(result_mfsir$betas[,1], type = 'l', main = "First Sufficient Predictor")
```

## Applications
Potential applications of fquantdr include, but are not limited to, the following fields:

* Biomedical data analysis
* Financial data modeling
* Environmental data analysis

For more detailed examples, please refer to the package documentation.

## Functions
__mfsir: Functional Sliced Inverse Regression__

Performs FSIR that can incorporate multivariate functional predictors.

__Arguments:__

* X: (n x t x p) array of functional elements (centered).
* y: Response variable.
* H: Number of slices.
* nbasis: Number of basis functions.

__Returns:__

* phi: Eigenvectors.
* betas: Sufficient predictors.
* eigvalues: Eigenvalues.
* xfd.coef: Coefficients of the functional data.
* gx: Gram matrix of the basis functions.

### fcqs: Functional Central Quantile Subspace
Fits a scalar-on-function regression for multivariate functional data.

__Arguments:__

* x: (n x t x p) array of functional elements.
* y: Response variable.
* t: Vector of time points.
* tau: Quantile level
* d_tau: Dimension of the FCQS.
* nbasis: Number of basis functions.

__Returns:__

* ffun: Functional parameters that span the FCQS..
* betax: Resulting sufficient predictor.

## Additional Utility Functions
These utility functions support various operations related to functional data analysis:

* __discretize__: Discretizes the response variable y into yunit slices, adding a small perturbation for stability.
* __slprob__: Computes slice proportions for the response variable.
* __slav__: Computes slice averages for the predictor coefficients.
* __symmetry__: Symmetrizes a matrix.



For more detailed examples and documentation, please refer to the package documentation and vignettes.
